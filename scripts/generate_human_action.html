<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Human Behaviour Data Collector</title>

    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        #area {
            width: 600px;
            height: 350px;
            border: 2px solid #222;
            margin-top: 20px;
            position: relative;
            user-select: none;
        }
        #target {
            width: 30px;
            height: 30px;
            background: red;
            border-radius: 50%;
            position: absolute;
        }
        #controls {
            margin-top: 15px;
        }
        button {
            padding: 10px 16px;
            font-size: 15px;
            margin-right: 10px;
        }
        #status {
            margin-top: 10px;
            font-size: 14px;
            color: #444;
        }
    </style>
</head>

<body>

<h1>Human Behaviour Tracking</h1>

<label>User name: </label>
<input type="text" id="userName" placeholder="Your name">

<br><br>

<label>Task: </label>
<input type="text" id="taskDesc" size="60" placeholder="Describe the task you're doing (e.g. follow the dot and click it)">

<div id="controls">
    <button id="startBtn">Start Tracking</button>
    <button id="stopBtn" disabled>Stop & Download CSV</button>
</div>

<div id="status">Status: idle</div>

<div id="area">
    <div id="target"></div>
</div>

<script>
    let isTracking = false;
    let startTime = 0;
    let lastEventTime = 0;
    let sessionId = null;
    let data = [];

    // we keep last known pointer pos so keyboard events have something
    let lastClientX = 0;
    let lastClientY = 0;

    const area = document.getElementById('area');
    const target = document.getElementById('target');
    const statusEl = document.getElementById('status');

    // Move target randomly inside area
    function moveTarget() {
        const x = Math.random() * (area.clientWidth - 30);
        const y = Math.random() * (area.clientHeight - 30);
        target.style.left = x + "px";
        target.style.top = y + "px";
    }
    setInterval(moveTarget, 1500);

    function setStatus(msg) {
        statusEl.textContent = "Status: " + msg;
    }

    // Start tracking
    document.getElementById("startBtn").addEventListener("click", () => {
        const uname = document.getElementById("userName").value.trim();
        if (!uname) {
            alert("Enter your name");
            return;
        }

        sessionId = "S_" + Math.random().toString(36).substring(2, 10);
        data = [];
        startTime = performance.now();
        lastEventTime = startTime;
        isTracking = true;

        document.getElementById("startBtn").disabled = true;
        document.getElementById("stopBtn").disabled = false;

        setStatus("tracking (session " + sessionId + ")");
        console.log("Tracking started:", sessionId);
    });

    // Stop tracking â†’ CSV download
    document.getElementById("stopBtn").addEventListener("click", () => {
        isTracking = false;
        document.getElementById("startBtn").disabled = false;
        document.getElementById("stopBtn").disabled = true;

        setStatus("stopped");
        generateCSV();
    });

    function trackEvent(e) {
        if (!isTracking) return;

        const currentTime = performance.now();
        const t_since_start = currentTime - startTime;
        const t_since_last = currentTime - lastEventTime;
        lastEventTime = currentTime;

        // base fields with safe defaults
        let eventType = e.type;

        // pointer-ish coords
        let clientX = 0;
        let clientY = 0;
        let pageX   = 0;
        let pageY   = 0;
        let screenX = 0;
        let screenY = 0;
        let relX    = 0;
        let relY    = 0;

        // mouse / click / wheel
        if (e.type.startsWith("mouse") || e.type === "click" || e.type === "wheel") {
            clientX = e.clientX;
            clientY = e.clientY;
            pageX   = e.pageX;
            pageY   = e.pageY;
            screenX = e.screenX;
            screenY = e.screenY;

            // offsetX/offsetY may be undefined for some targets
            if (typeof e.offsetX === "number") {
                relX = e.offsetX;
                relY = e.offsetY;
            } else {
                // fallback: relative to area
                const rect = area.getBoundingClientRect();
                relX = e.clientX - rect.left;
                relY = e.clientY - rect.top;
            }
        }
        // touch events
        else if (e.type.startsWith("touch")) {
            const t = (e.touches && e.touches[0]) || (e.changedTouches && e.changedTouches[0]);
            if (t) {
                clientX = t.clientX;
                clientY = t.clientY;
                pageX   = t.pageX;
                pageY   = t.pageY;
                screenX = t.screenX;
                screenY = t.screenY;

                const rect = area.getBoundingClientRect();
                relX = t.clientX - rect.left;
                relY = t.clientY - rect.top;
            }
        }
        // keyboard events: reuse last known pointer position
        else if (e.type.startsWith("key")) {
            clientX = lastClientX;
            clientY = lastClientY;
            pageX   = clientX;
            pageY   = clientY;
            screenX = clientX;
            screenY = clientY;
            relX    = 0;
            relY    = 0;
        }

        // velocity: only meaningful when coords change
        let prevX = (data.length > 0) ? data[data.length - 1].client_x : clientX;
        let prevY = (data.length > 0) ? data[data.length - 1].client_y : clientY;
        let dx = clientX - prevX;
        let dy = clientY - prevY;
        let dist = Math.sqrt(dx * dx + dy * dy);
        let velocity = 0.0;
        if (t_since_last > 0 && (e.type.startsWith("mouse") || e.type.startsWith("touch") || e.type === "click")) {
            velocity = dist / (t_since_last / 1000.0);
        }

        lastClientX = clientX;
        lastClientY = clientY;

        const row = {
            session_id: sessionId,
            timestamp: Date.now(),
            time_since_start: t_since_start.toFixed(3),
            time_since_last_event: t_since_last.toFixed(3),
            event_type: eventType,
            client_x: clientX,
            client_y: clientY,
            relative_x: relX,
            relative_y: relY,
            page_x: pageX,
            page_y: pageY,
            screen_x: screenX,
            screen_y: screenY,
            button: e.button !== undefined ? e.button : 0,
            buttons: e.buttons !== undefined ? e.buttons : 0,
            ctrl_key: !!e.ctrlKey,
            shift_key: !!e.shiftKey,
            alt_key: !!e.altKey,
            meta_key: !!e.metaKey,
            velocity: velocity.toFixed(3)
        };

        data.push(row);
    }

    // Attach listeners on area for pointer events
    area.addEventListener("mousemove", trackEvent);
    area.addEventListener("mousedown", trackEvent);
    area.addEventListener("mouseup", trackEvent);
    area.addEventListener("click", trackEvent);
    area.addEventListener("mouseenter", trackEvent);
    area.addEventListener("mouseleave", trackEvent);

    // Wheel events (global)
    window.addEventListener("wheel", trackEvent, { passive: true });

    // Keyboard events (global) - useful if your captcha has typing
    document.addEventListener("keydown", trackEvent);
    document.addEventListener("keyup", trackEvent);

    // Touch events (for touchscreens)
    area.addEventListener("touchstart", trackEvent, { passive: true });
    area.addEventListener("touchmove", trackEvent, { passive: true });
    area.addEventListener("touchend", trackEvent, { passive: true });

    // CSV creator
    function generateCSV() {
        if (data.length === 0) {
            alert("No data captured!");
            return;
        }

        const headers = Object.keys(data[0]);
        let csv = headers.join(",") + "\n";

        data.forEach(row => {
            const vals = headers.map(h => String(row[h]).replace(/,/g, " "));
            csv += vals.join(",") + "\n";
        });

        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = `human_session_${sessionId}.csv`;
        a.click();

        URL.revokeObjectURL(url);
    }
</script>

</body>
</html>
